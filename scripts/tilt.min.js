var VanillaTilt = (function () {
    "use strict";

    class TiltEffect {
        constructor(element, settings = {}) {
            if (!(element instanceof Node)) {
                throw "Can't initialize VanillaTilt because " + element + " is not a Node.";
            }

            // Element references
            this.element = element;
            this.settings = this.extendSettings(settings);
            this.reverse = this.settings.reverse ? -1 : 1;
            this.resetToStart = TiltEffect.isSettingTrue(this.settings["reset-to-start"]);
            this.glare = TiltEffect.isSettingTrue(this.settings.glare);
            this.glarePrerender = TiltEffect.isSettingTrue(this.settings["glare-prerender"]);
            this.fullPageListening = TiltEffect.isSettingTrue(this.settings["full-page-listening"]);
            this.gyroscope = TiltEffect.isSettingTrue(this.settings.gyroscope);
            this.gyroscopeSamples = this.settings.gyroscopeSamples;
            this.elementListener = this.getElementListener();

            // Bindings
            this.updateBind = this.update.bind(this);
            this.resetBind = this.reset.bind(this);

            // State
            this.transitionTimeout = null;
            this.updateCall = null;
            this.event = null;
            this.width = null;
            this.height = null;
            this.left = null;
            this.top = null;
            this.clientWidth = null;
            this.clientHeight = null;
            this.gammazero = null;
            this.betazero = null;
            this.lastgammazero = null;
            this.lastbetazero = null;

            // Setup
            this.glare && this.prepareGlare();
            this.fullPageListening && this.updateClientSize();
            this.addEventListeners();
            this.reset();

            if (!this.resetToStart) {
                this.settings.startX = 0;
                this.settings.startY = 0;
            }
        }

        static isSettingTrue(value) {
            return value === "" || value === true || value === 1;
        }

        getElementListener() {
            if (this.fullPageListening) return window.document;

            if (typeof this.settings["mouse-event-element"] === "string") {
                const el = document.querySelector(this.settings["mouse-event-element"]);
                if (el) return el;
            }

            if (this.settings["mouse-event-element"] instanceof Node) {
                return this.settings["mouse-event-element"];
            }

            return this.element;
        }

        addEventListeners() {
            this.onMouseEnterBind = this.onMouseEnter.bind(this);
            this.onMouseMoveBind = this.onMouseMove.bind(this);
            this.onMouseLeaveBind = this.onMouseLeave.bind(this);
            this.onWindowResizeBind = this.onWindowResize.bind(this);
            this.onDeviceOrientationBind = this.onDeviceOrientation.bind(this);

            this.elementListener.addEventListener("mouseenter", this.onMouseEnterBind);
            this.elementListener.addEventListener("mousemove", this.onMouseMoveBind);
            this.elementListener.addEventListener("mouseleave", this.onMouseLeaveBind);

            if (this.glare || this.fullPageListening) {
                window.addEventListener("resize", this.onWindowResizeBind);
            }

            if (this.gyroscope) {
                window.addEventListener("deviceorientation", this.onDeviceOrientationBind);
            }
        }

        removeEventListeners() {
            this.elementListener.removeEventListener("mouseenter", this.onMouseEnterBind);
            this.elementListener.removeEventListener("mousemove", this.onMouseMoveBind);
            this.elementListener.removeEventListener("mouseleave", this.onMouseLeaveBind);

            if (this.gyroscope) {
                window.removeEventListener("deviceorientation", this.onDeviceOrientationBind);
            }

            if (this.glare || this.fullPageListening) {
                window.removeEventListener("resize", this.onWindowResizeBind);
            }
        }

        destroy() {
            clearTimeout(this.transitionTimeout);
            cancelAnimationFrame(this.updateCall);

            this.element.style.willChange = "";
            this.element.style.transition = "";
            this.element.style.transform = "";

            this.resetGlare();
            this.removeEventListeners();

            this.element.vanillaTilt = null;
            delete this.element.vanillaTilt;
        }

        onDeviceOrientation(event) {
            if (event.gamma === null || event.beta === null) return;

            this.updateElementPosition();

            if (this.gyroscopeSamples > 0) {
                this.lastgammazero = this.gammazero;
                this.lastbetazero = this.betazero;

                if (this.gammazero === null) {
                    this.gammazero = event.gamma;
                    this.betazero = event.beta;
                } else {
                    this.gammazero = (event.gamma + this.lastgammazero) / 2;
                    this.betazero = (event.beta + this.lastbetazero) / 2;
                }

                this.gyroscopeSamples -= 1;
            }

            const angleX = this.settings.gyroscopeMaxAngleX - this.settings.gyroscopeMinAngleX;
            const angleY = this.settings.gyroscopeMaxAngleY - this.settings.gyroscopeMinAngleY;
            const x = (event.gamma - (this.settings.gyroscopeMinAngleX + this.gammazero)) / (angleX / this.width);
            const y = (event.beta - (this.settings.gyroscopeMinAngleY + this.betazero)) / (angleY / this.height);

            this.event = { clientX: x + this.left, clientY: y + this.top };

            cancelAnimationFrame(this.updateCall);
            this.updateCall = requestAnimationFrame(this.updateBind);
        }

        onMouseEnter() {
            this.updateElementPosition();
            this.element.style.willChange = "transform";
            this.setTransition();
        }

        onMouseMove(event) {
            cancelAnimationFrame(this.updateCall);
            this.event = event;
            this.updateCall = requestAnimationFrame(this.updateBind);
        }

        onMouseLeave() {
            this.setTransition();
            if (this.settings.reset) {
                requestAnimationFrame(this.resetBind);
            }
        }

        reset() {
            this.onMouseEnter();

            if (this.fullPageListening) {
                this.event = {
                    clientX: (this.settings.startX + this.settings.max) / (2 * this.settings.max) * this.clientWidth,
                    clientY: (this.settings.startY + this.settings.max) / (2 * this.settings.max) * this.clientHeight,
                };
            } else {
                this.event = {
                    clientX: this.left + ((this.settings.startX + this.settings.max) / (2 * this.settings.max) * this.width),
                    clientY: this.top + ((this.settings.startY + this.settings.max) / (2 * this.settings.max) * this.height),
                };
            }

            const scale = this.settings.scale;
            this.settings.scale = 1;
            this.update();
            this.settings.scale = scale;

            this.resetGlare();
        }

        resetGlare() {
            if (this.glare) {
                this.glareElement.style.transform = "rotate(180deg) translate(-50%, -50%)";
                this.glareElement.style.opacity = "0";
            }
        }

        getValues() {
            let x, y;

            if (this.fullPageListening) {
                x = this.event.clientX / this.clientWidth;
                y = this.event.clientY / this.clientHeight;
            } else {
                x = (this.event.clientX - this.left) / this.width;
                y = (this.event.clientY - this.top) / this.height;
            }

            x = Math.min(Math.max(x, 0), 1);
            y = Math.min(Math.max(y, 0), 1);

            return {
                tiltX: (this.reverse * (this.settings.max - x * this.settings.max * 2)).toFixed(2),
                tiltY: (this.reverse * (y * this.settings.max * 2 - this.settings.max)).toFixed(2),
                percentageX: x * 100,
                percentageY: y * 100,
                angle: Math.atan2(this.event.clientX - (this.left + this.width / 2), -(this.event.clientY - (this.top + this.height / 2))) * (180 / Math.PI),
            };
        }

        updateElementPosition() {
            const rect = this.element.getBoundingClientRect();
            this.width = this.element.offsetWidth;
            this.height = this.element.offsetHeight;
            this.left = rect.left;
            this.top = rect.top;
        }

        update() {
            const values = this.getValues();

            this.element.style.transform = `perspective(${this.settings.perspective}px)
        rotateX(${this.settings.axis === "x" ? 0 : values.tiltY}deg)
        rotateY(${this.settings.axis === "y" ? 0 : values.tiltX}deg)
        scale3d(${this.settings.scale}, ${this.settings.scale}, ${this.settings.scale})`;

            if (this.glare) {
                this.glareElement.style.transform = `rotate(${values.angle}deg) translate(-50%, -50%)`;
                this.glareElement.style.opacity = `${(values.percentageY * this.settings["max-glare"]) / 100}`;
            }

            this.element.dispatchEvent(new CustomEvent("tiltChange", { detail: values }));
            this.updateCall = null;
        }

        prepareGlare() {
            if (!this.glarePrerender) {
                const glareWrapper = document.createElement("div");
                glareWrapper.classList.add("js-tilt-glare");

                const glareInner = document.createElement("div");
                glareInner.classList.add("js-tilt-glare-inner");

                glareWrapper.appendChild(glareInner);
                this.element.appendChild(glareWrapper);
            }

            this.glareElementWrapper = this.element.querySelector(".js-tilt-glare");
            this.glareElement = this.element.querySelector(".js-tilt-glare-inner");

            if (!this.glarePrerender) {
                Object.assign(this.glareElementWrapper.style, {
                    position: "absolute",
                    top: "0",
                    left: "0",
                    width: "100%",
                    height: "100%",
                    overflow: "hidden",
                    pointerEvents: "none",
                    borderRadius: "inherit",
                });

                Object.assign(this.glareElement.style, {
                    position: "absolute",
                    top: "50%",
                    left: "50%",
                    pointerEvents: "none",
                    backgroundImage: "linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)",
                    transform: "rotate(180deg) translate(-50%, -50%)",
                    transformOrigin: "0% 0%",
                    opacity: "0",
                });

                this.updateGlareSize();
            }
        }

        updateGlareSize() {
            if (this.glare) {
                const size = Math.max(this.element.offsetWidth, this.element.offsetHeight) * 2;
                Object.assign(this.glareElement.style, {
                    width: `${size}px`,
                    height: `${size}px`,
                });
            }
        }

        updateClientSize() {
            this.clientWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            this.clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        }

        onWindowResize() {
            this.updateGlareSize();
            this.updateClientSize();
        }

        setTransition() {
            clearTimeout(this.transitionTimeout);
            this.element.style.transition = `${this.settings.speed}ms ${this.settings.easing}`;

            if (this.glare) {
                this.glareElement.style.transition = `opacity ${this.settings.speed}ms ${this.settings.easing}`;
            }

            this.transitionTimeout = setTimeout(() => {
                this.element.style.transition = "";
                if (this.glare) this.glareElement.style.transition = "";
            }, this.settings.speed);
        }

        extendSettings(settings) {
            const defaults = {
                reverse: false,
                max: 15,
                startX: 0,
                startY: 0,
                perspective: 1000,
                easing: "cubic-bezier(.03,.98,.52,.99)",
                scale: 1,
                speed: 300,
                transition: true,
                axis: null,
                glare: false,
                "max-glare": 1,
                "glare-prerender": false,
                "full-page-listening": false,
                "mouse-event-element": null,
                reset: true,
                "reset-to-start": true,
                gyroscope: true,
                gyroscopeMinAngleX: -45,
                gyroscopeMaxAngleX: 45,
                gyroscopeMinAngleY: -45,
                gyroscopeMaxAngleY: 45,
                gyroscopeSamples: 10,
            };

            const newSettings = {};
            for (const prop in defaults) {
                if (prop in settings) {
                    newSettings[prop] = settings[prop];
                } else if (this.element.hasAttribute("data-tilt-" + prop)) {
                    const attr = this.element.getAttribute("data-tilt-" + prop);
                    try {
                        newSettings[prop] = JSON.parse(attr);
                    } catch {
                        newSettings[prop] = attr;
                    }
                } else {
                    newSettings[prop] = defaults[prop];
                }
            }

            return newSettings;
        }

        static init(elements, settings) {
            if (elements instanceof Node) elements = [elements];
            if (elements instanceof NodeList) elements = [].slice.call(elements);

            if (Array.isArray(elements)) {
                elements.forEach(el => {
                    if (!("vanillaTilt" in el)) {
                        el.vanillaTilt = new TiltEffect(el, settings);
                    }
                });
            }
        }
    }

    if (typeof document !== "undefined") {
        window.VanillaTilt = TiltEffect;
        TiltEffect.init(document.querySelectorAll("[data-tilt]"));
    }

    return TiltEffect;
})();